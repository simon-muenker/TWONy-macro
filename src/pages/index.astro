---
import "../styles/global.css";

import Header from "@components/Header.astro";
import Footer from "@components/Footer.astro";
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>TWONy-macro</title>
  </head>
  <body>
    <div class="absolute top-0 left-0 z-50 w-full md:w-1/3">
      <Header />
    </div>
    <main>
      <div id="3d-graph"></div>
      <div class="absolute top-1/2 right-4 z-50 -translate-y-1/2">
        <canvas id="eval-chart" width="256" height="180"> </canvas>
      </div>
    </main>
    <div class="absolute right-0 bottom-0 z-50 w-full">
      <Footer />
    </div>
  </body>

  <script>
    import ForceGraph3D from "3d-force-graph";
    import { interpolateRdYlGn } from "d3";
    import { Vector2 } from "three";
    import { GUI } from "dat.gui";
    import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
    import Chart from "chart.js/auto";

    import {
      generateNodeData,
      generateNodes,
      generateLinks,
    } from "@logic/generator.ts";
    import { CONFIG } from "@logic/config.ts";

    const DATA = generateNodeData(CONFIG.network.n_agents);
    const graphEL: HTMLElement = document.getElementById(
      "3d-graph",
    ) as HTMLElement;

    const canvasEL: HTMLCanvasElement = document.getElementById(
      "eval-chart",
    ) as HTMLCanvasElement;
    const canvasCTX: CanvasRenderingContext2D = canvasEL.getContext(
      "2d",
    ) as CanvasRenderingContext2D;

    let evaluation = [
      DATA.reduce((total, next) => total + next.sentiment, 0) / DATA.length,
    ];

    const gui = new GUI({
      name: "Configuration",
      width: 256,
    });
    const guiNet = gui.addFolder("Network");
    guiNet.add(CONFIG.network, "n_agents", 10, 5000, 10).name("Num. Agents");
    guiNet.add(CONFIG.network, "n_neighbors", 1, 50, 1).name("Num. Neighbors");

    const guiModel = gui.addFolder("Model");
    guiModel
      .add(CONFIG.model, "sorting", [
        "random",
        "similarity",
        "positivity",
        "negativity",
      ])
      .name("Sorting");
    guiModel.add(CONFIG.model, "n_steps", 1, 1000, 1).name("Num. Steps");
    guiModel.add(CONFIG.model, "eps_bcm", 0.01, 1, 0.01).name("BCM Epsilon");
    guiModel.add(CONFIG.model, "eps_rei", 0.01, 1, 0.01).name("REI Epsilon");
    guiModel.add(CONFIG.model, "delta_bcm", 0.01, 1, 0.01).name("BCM Delta");

    const guiUtil = gui.addFolder("Utilities");
    guiUtil.add(CONFIG.utilities, "distance", 100, 5000, 10).name("Distance");

    const Graph = new ForceGraph3D(graphEL)
      .nodeRelSize(8)
      .backgroundColor(CONFIG.utilities.backgroundColor)
      .nodeColor((node) => interpolateRdYlGn((node as any).data.sentiment))
      .graphData({
        nodes: generateNodes(CONFIG.network.n_agents, DATA),
        links: generateLinks(CONFIG.network.n_agents),
      });

    const controls = {
      start: function () {
        console.log("clicked");
      },
      reset: function () {
        console.log("reset");
      },
    };
    gui.add(controls, "start").name("Start");
    gui.add(controls, "reset").name("Reset");

    let chart = new Chart(canvasCTX, {
      type: "line",
      data: {
        labels: Object.keys(evaluation),
        datasets: [
          {
            label: "Average Sentiment",
            data: evaluation,
            borderColor: "rgb(255, 255, 255)",
            fill: false,
            tension: 0.1,
          },
        ],
      },
      options: {
        scales: {
          x: {
            display: false,
          },
        },
      },
    });

    setInterval(() => {
      for (let i = 0; i < DATA.length; i++) {
        DATA[i].sentiment = DATA[i].sentiment + (Math.random() - 0.5) * 0.5;
      }

      Graph.nodeColor((node) =>
        interpolateRdYlGn((node as any).data.sentiment),
      );

      evaluation.push(
        DATA.reduce((total, next) => total + next.sentiment, 0) / DATA.length,
      );
      chart.data.labels = Object.keys(evaluation);
      chart.update();
    }, 250);

    // camera orbit
    let angle = 0;
    setInterval(() => {
      Graph.cameraPosition({
        x: CONFIG.utilities.distance * Math.sin(angle),
        z: CONFIG.utilities.distance * Math.cos(angle),
      });
      angle += Math.PI / 3200;
    }, 10);

    if (CONFIG.utilities.bloomFilter) {
      const bloomPass = new UnrealBloomPass(
        new Vector2(window.innerWidth, window.innerHeight),
        4, // strength
        1, // radius
        0, // threshold
      );

      Graph.postProcessingComposer().addPass(bloomPass);
    }
  </script>
</html>
